

from __future__ import annotations

from typing import Callable
import logging
import dolfinx.fem.petsc
from packaging.version import parse as _v

import numpy as np
from petsc4py import PETSc
import ufl
import dolfinx


__all__ = ["NewtonSolver", "BlockedNewtonSolver"]

logger = logging.getLogger(__name__)

# assemble_vector_block(scale=...) is renamed assemble_vector_block(alpha=...)
# in 0.9
_alpha_kw: str = "alpha"
if _v(dolfinx.__version__) < _v("0.9"):
    _alpha_kw = "scale"




class NestedNewtonSolver(dolfinx.cpp.nls.petsc.NewtonSolver):
    def __init__(
        self,
        F: list[ufl.form.Form],
        u: list[dolfinx.fem.Function],
        mpc,
        bcs: list[dolfinx.fem.DirichletBC] = [],
        J: list[list[ufl.form.Form]] | None = None,
        form_compiler_options: dict | None = None,
        jit_options: dict | None = None,
        petsc_options: dict | None = None,
        entity_maps: dict | None = None,
    ):
        """Initialize solver for solving a non-linear problem using Newton's method.
        Args:
            F: List of PDE residuals [F_0(u, v_0), F_1(u, v_1), ...]
            u: List of unknown functions u=[u_0, u_1, ...]
            bcs: List of Dirichlet boundary conditions
            J: UFL representation of the Jacobian (Optional)
                Note:
                    If not provided, the Jacobian will be computed using the
                    assumption that the test functions come from a ``ufl.MixedFunctionSpace``
            form_compiler_options: Options used in FFCx
                compilation of this form. Run ``ffcx --help`` at the
                command line to see all available options.
            jit_options: Options used in CFFI JIT compilation of C
                code generated by FFCx. See ``python/dolfinx/jit.py``
                for all available options. Takes priority over all
                other option values.
            petsc_options:
                Options passed to the PETSc Krylov solver.
            entity_maps: Maps used to map entities between different meshes.
                Only needed if the forms have not been compiled a priori,
                and has coefficients, test, or trial functions that are defined on different meshes.
        """
        # Initialize base class
        super().__init__(u[0].function_space.mesh.comm)

        # Set PETSc options for Krylov solver
        prefix = self.krylov_solver.getOptionsPrefix()
        if prefix is None:
            prefix = ""
        if petsc_options is not None:
            # Set PETSc options
            opts = PETSc.Options()
            opts.prefixPush(prefix)
            for k, v in petsc_options.items():
                opts[k] = v
            opts.prefixPop()
            self.krylov_solver.setFromOptions()
        
        self._F = dolfinx.fem.form(
            F,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )

        # Create the Jacobian matrix, dF/du
        if J is None:
            if _v(dolfinx.__version__) < _v("0.9"):
                raise RuntimeError(
                    "Automatic computation of Jacobian for blocked problem is only"
                    + "supported in DOLFINx 0.9 and later"
                )
            du = ufl.TrialFunctions(ufl.MixedFunctionSpace(*[ui.function_space for ui in u]))
            J = ufl.extract_blocks(sum(ufl.derivative(sum(F), u[i], du[i]) for i in range(len(u))))
        self._a = dolfinx.fem.form(
            J,
            form_compiler_options=form_compiler_options,
            jit_options=jit_options,
            entity_maps=entity_maps,
        )
        self._bcs = bcs
        self._u = u
        self._pre_solve_callback: Callable[["NestedNewtonSolver"], None] | None = None
        self._post_solve_callback: Callable[["NestedNewtonSolver"], None] | None = None

        # Create structures for holding arrays and matrix
        self._b = dolfinx.fem.petsc.create_vector_nest(self._F)
        print("intialized ", self._b.getSize())
        self._J = dolfinx.fem.petsc.create_matrix_nest(self._a)
        print("intialized jacobian ", self._J.getSize(), self._J.getType())
        self._dx = dolfinx.fem.petsc.create_vector_nest(self._F)
        self._x = dolfinx.fem.petsc.create_vector_nest(self._F)
        self._J.setOptionsPrefix(prefix)
        self._J.setFromOptions()

        self.setF(self._assemble_residual, self._b)
        self.setJ(self._assemble_jacobian, self._J)
        self.set_form(self._pre_newton_iteration)
        self.set_update(self._update_function)






    def set_pre_solve_callback(self, callback: Callable[["NestedNewtonSolver"], None]):
        """Set a callback function that is called before each Newton iteration."""
        self._pre_solve_callback = callback

    def set_post_solve_callback(self, callback: Callable[["NestedNewtonSolver"], None]):
        """Set a callback function that is called after each Newton iteration."""
        self._post_solve_callback = callback

    @property
    def L(self) -> list[dolfinx.fem.Form]:
        """Compiled linear form (the residual form)"""
        return self._F

    @property
    def a(self) -> list[list[dolfinx.fem.Form]]:
        """Compiled bilinear form (the Jacobian form)"""
        print("called the bilinear form", self._a.getType())
        return self._a

    @property
    def u(self):
        return self._u

    def __del__(self):
        self._J.destroy()
        self._b.destroy()
        self._dx.destroy()
        self._x.destroy()

    def _pre_newton_iteration(self, x: PETSc.Vec) -> None:
        """Function called before the residual or Jacobian is
        computed.
        Args:
           x: The vector containing the latest solution
        """
        print("preiteration ",x.getArray() )
        if self._pre_solve_callback is not None:
            self._pre_solve_callback(self)
        # Scatter previous solution `u=[u_0, ..., u_N]` to `x`; the
        # blocked version used for lifting
        for i,x_sub in enumerate(x.getNestSubVecs()):
            dolfinx.cpp.la.petsc.scatter_local_vectors(
                x_sub,
                [self._u[i].x.petsc_vec.array_r],
                [
                (
                    self._u[i].function_space.dofmap.index_map,
                    self._u[i].function_space.dofmap.index_map_bs,
                )
                ],)
            x_sub.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        print("Post-preiteration ",x.getArray() )

    def _assemble_residual(self, x: PETSc.Vec, b: PETSc.Vec) -> None:
        """Assemble the residual F into the vector b.
        Args:
            x: The vector containing the latest solution
            b: Vector to assemble the residual into
        """
        # Assemble F(u_{i-1}) - J(u_D - u_{i-1}) and set du|_bc= u_D - u_{i-1}
        print("Before Assembling", b.getType(),b.getArray(),x.getType(),x.getArray())
        for b_sub in b.getNestSubVecs():
            with b_sub.localForm() as b_local:
                b_local.set(0.0)
        # with b.localForm() as b_local:
        #     b_local.set(0.0)
        dolfinx.fem.petsc.assemble_vector_nest(
            b,
            self._F,
        )
        
        dolfinx.fem.petsc.apply_lifting_nest(b, self._a, self._bcs)
        for b_sub in b.getNestSubVecs():
            b_sub.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)
        print("Assembling residual", b.getArray(),x.getArray())

        # print("b=",b.getArray())
        # print("x=",x.getArray())
        bcs0 = dolfinx.fem.bcs_by_block(dolfinx.fem.extract_function_spaces(self._F), self._bcs)
        dolfinx.fem.petsc.set_bc_nest(b, bcs0)
        print("Assembling", b.getType(),b.getArray(),x.getType(),x.getArray())

    def _assemble_jacobian(self, x: PETSc.Vec, A: PETSc.Mat) -> None:
        """Assemble the Jacobian matrix.
        Args:
            x: The vector containing the latest solution
        """
        # Assemble Jacobian
        print("Jacobian type is:", A.getType())
        A.zeroEntries()
        dolfinx.fem.petsc.assemble_matrix_nest(A, self._a, bcs=self._bcs)
        A.assemble()
        print("Jacobian type is:", A.getType())
        print("Size matrix ",A.getSize())
        # print( A.convert('seqaij').getValuesCSR())
        # print("Jacobian type is:", A.getType())

    def _update_function(self, solver, dx: PETSc.Vec, x: PETSc.Vec):
        print("started updating ", self._u[0].x.array,self._u[1].x.array)
        print("dx= ",dx.getArray())
        if self._post_solve_callback is not None:
            self._post_solve_callback(self)
        # Update solution
        offset_start = 0
        for ui in self._u:
            Vi = ui.function_space
            num_sub_dofs = Vi.dofmap.index_map.size_local * Vi.dofmap.index_map_bs
            ui.x.petsc_vec.array_w[:num_sub_dofs] -= (
                self.relaxation_parameter * dx.array_r[offset_start : offset_start + num_sub_dofs]
            )
            ui.x.petsc_vec.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
            offset_start += num_sub_dofs
        print("Done updating ",  self._u[0].x.array,self._u[1].x.array)

        

    def solve(self):
        """Solve non-linear problem into function. Returns the number
        of iterations and if the solver converged."""
        print("Starting solver")
        dolfinx.log.set_log_level(dolfinx.log.LogLevel.INFO)
        print("SOlving with ", self._x,self._x.getArray())
        n, converged = super().solve(self._x)
        for x_sub in self._x.getNestSubVecs():
            x_sub.ghostUpdate(addv=PETSc.InsertMode.INSERT, mode=PETSc.ScatterMode.FORWARD)
        return n, converged